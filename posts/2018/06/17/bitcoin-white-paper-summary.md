---
title: Bitcoin) 비트코인 백서 요약
date: 2018-06-17 07:57:05
published: true
tags:
  - bitcoin
description:
  '비트코인 백서 요약 [출처](https://bitcoin.org/bitcoin.pdf)  ### 1. 서론  인터넷
  상거래는 전자 결제를 처리할 신뢰받는 제3자 역할을 금융기관에 전적으로 의지했다. 중재비용은 거래비용을 높이고, 비실용적이며 당사자에게 많은
  개인정보를 제공해야 한다. 신뢰 대신 암호학적인 증명을 바탕으로, 거래 의사가 있는 두 당사자가 신...'
category: bitcoin
slug: /2018/06/17/bitcoin-white-paper-summary/
template: post
---

비트코인 백서 요약

[출처](https://bitcoin.org/bitcoin.pdf)

### 1. 서론

인터넷 상거래는 전자 결제를 처리할 신뢰받는 제3자 역할을 금융기관에 전적으로 의지했다. 중재비용은 거래비용을 높이고, 비실용적이며 당사자에게 많은 개인정보를 제공해야 한다. 신뢰 대신 암호학적인 증명을 바탕으로, 거래 의사가 있는 두 당사자가 신뢰받는 제 3 자를 필요로 하지 않고 서로 직접 거래하게 해주는 전자 화폐 시스템이이다. 거래 시간순서대로 전산적 증명을 생성하는, 개인 대 개인간 분산 타임스탬프 서버를 사용한 이중지불 문제의 솔루션을 제안한다.이 시스템은 정직한 노드가 공격하려고 협력하는 노드보다 더 많은 CPU파워를 통제하는 한 안전하다.

### 2. 거래

1.  이전의 거래내역 및 다음 소유자 공개키의 해시값에 전자서명을 한다.
2.  1에서 생성된 정보를 화폐의 끝에 추가한다.
3.  돈을 받는 사람은 소유권의 사슬 검증하기 위해 해당 서명을 검증할 수 있다.

그러나 이 과정에서는 화폐가 이전에 사용되지 않았는지 (어떤 거래에도 서명하지 않았는지) 수금자가 알 수가 없다. 이 것을 확인하는 유일한 방법은 모든 거래 내역을 인지하는 것 뿐이다. 기존에는 조폐국이 모든 거래내역을 알고 있었다면, 제 3자 없이 이방법을 실현하기 위해서는 거래내역이 공개적으로 알려져야 한다. 노드들이 거래 받는 순서의 단일이력에 합의하는 시스템이 필요하다. 수금자는 매 거래시 그것이 첫 수금이라는 사실에 다수의 노드가 동의 했음을 증명해야 한다.

![transaction](../images/transaction.png)

### 3. 타임스탬프 서버

타임스탬프 서버는 타임스탬프가 찍힌 항목의 블록의 해시를 가져가 널리 배포한다. 이 타임스탬프는 해쉬안에 먼젓번 타임스탬프를 포함하고, 앞선 것을 물고있는 사슬을 형성한다.

![timestmap](../images/timestamp.png)

### 4. 작업증명

3번의 타임스탬프 서버를 구현하기 위해서는 작업증명시스템을 사용해야 한다. 작업증명은 SHA256 같은 해시된 값 스캐닝을 필요로 한다. 블록의 해시에 필요한 0 비트를 주는 값이 발견될 때 까지 nonce값을 증분 하는 것으로 작업증명을 구현하는 것이다. 이런 재수행 작업뒤 모든 블록을 포함한다.
작업증명은 기본적으로 CPU당 1표다. 다수의사는 최대 작업증명 동작이 투입된 가장 긴 사슬로 대표된다. 다수 CPU파워가 정직한 노드에 의해 통제되면, 가장 정직한 사슬이 빠르게 늘어날 것이다. 과거 블록을 변경하려면 그 블록을 포함한 뒤의 모든 블록 작업증명을 재수행 해야 하고, 정직한 노드의 작업 또한 따라 잡아야 한다.
시간이 지날수록 노드를 구동하는 하드웨어 속도 증가와 관여도를 보상하기 위해, 작업 증명 난이도는 시간당 평균 블록수에 따른 평균 목표치를 조정해 결정된다. 빨리 생성되면, 난이도도 증가한다.

![proof-of-work](../images/proof-of-work.png)

### 5. 네트워크

1.  새로운 거래가 모든 노드들에게 전파된다
2.  각각의 노드들은 새로운 거래를 블록에 집어 넣는다
3.  각각의 노드들은 그 블록에 맞는 난이도의 작업증명을 찾기에 나선다.
4.  노드가 작업증명을 찾으면, 모든 노드에게 그 블록을 알린다.
5.  노드는 모든 거래가 유효하며 아직 지불되지 않았다면 그 블록을 승인한다.
6.  노드는 블록 승인을 알리기 위해 먼저번 해시로 승인된 블록의 해시를 사용해 사슬안에 다음 블록을 생성한다. 노드는 항상 긴 사슬x을 정확한 것으로 판단하고 그것을 잇는다.

### 6. 인센티브

블록의 첫번째 거래는 블록의 작성자가 소유한 코인으로 시작한다. 네트워크를 지원하는 노드가 자신이 생성한 블록의 양만큼 코인으로 보상을 받는다. 새 화폐 일정량을 추가하는 것은, 자원을 발견하도록 자원을 소비하는 것과 유사하다. 이경우에는 CPU와 전기다. 이러한 인센티브는 공격으로 부터 방어하는 수단이 될 수도 있다. 정직한 노드보다 더많은 CPU파워를 모은다면, 다른 모든 사람의 지불금을 훔치는 것보다 더 많은 코인을 생성하게 하면 된다.

### 7. 디스크 공간 회수

화폐 안에 최종 거래가 충분한 블록에 묻히면, 그 이전 거래는 디스크 공간 절약을 위해 폐기 될 수 있다. 블록의 해시를 깨지 않고 이 방법을 실현하기 위해서는, 이 거래를 머클트리로 해시한다. 그리고 그 루트만 블록의 해시에 포함시킨다.

![reclaiming-disk-space](../images/reclaiming-disk-space.png)

### 8. 간소화된 결제 검증

1. 사용자가 최장 작업증명 사슬을 가졌다고 확신할때까지 네트워크 노드를 조회한다.
2. 얻을 수 있는 가장 긴 사슬의 블록헤더 사본을 유지 한다.
3. 해당 거래를 타임스탬프가 찍힌 블록에 연결한 머클 분기를 얻기만 하면 된다.

비록 자신의 거래는 검사할 수 없지만, 그것을 사본과 연결 버전과, 이 후 그게 받아드려진 뒤 추가된 블록을 비교해 볼 수 있다.

![longest-proof-of-work-chain](../images/chain.png)

### 9. 나누기와 합치기

1. 모든 송금을 별도의 거래로 만드는 것은 무리이므로, 거래는 복수의 입출금을 포함한다. 이렇게 여러개를 합치게 된다면, 입금은 먼젓번 거래의 단수입금 이나 작은 양을 합친 복수입금이고, 출금은 지불용 출금과 거스름돈 정도가 있을 것이다.

![combine-split](../images/combine-split.png)

### 10. 프라이버시

네트워크 내에 거래는 공개되 있지만, 신원은 거래와 가치로부터 분리되어 보관된다. 사용자는 작업과 관련된 정보를 피하기 위해 공개키를 가지게 된다.

![privacy](../images/privacy.png)

### 11. 계산

정직한 노드가 사기 노드보다 먼저 블록을 찾을 확률이 더 높다. 사기성 블록을 만들때, 사기성 노드가 정직한 노드를 따라잡을 가능성은 낮다. 이는 노드가 가장 긴 사슬을 올바른 사슬로 인식하므로, 블록체인의 크기를 늘릴 때 중요하다.

### 12. 결론

디지털서명으로 만든 화폐의 프레임워크에서 핵심은 이중지불 방지수단을 만드는 것이다. 이를 해결하기 위해, 정직한 노드가 CPU 파워 대부분을 차지 한다면, 공격자는 전산적으로 변경하기가 어려워지는 작업 증명 방식을 사용했다. 이 네트워크는 조정없이 한번에 동작한다. 어떤 특정 경로로 가는 것이 아니라, 최선의 노력을 통해 전달 되기만 하면 된다. 노드는 네트워크를 떠났다가, 작업증명 사슬을 받아드리고 다시합류할 수도 있다. CPU파워를 사용한 투표로, 유효한 블록을 연장하는 작업을 통해 그것을 승인하고, 유효하지 않은 블록에 대해서는 기각한다. 이러한 것을 Consensus mechanism이라고 한다.
